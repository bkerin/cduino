#!/usr/bin/perl -w

use strict;
use warnings FATAL => 'all';

use Carp;
use Fcntl;
use IO::Handle;
use Scalar::Util qw(looks_like_number);
use Time::HiRes qw( time usleep );

my $df = '/dev/ttyUSB0';

sub as_uint8 # {{{1
{
    # Return the argument with all bits higher than the 8th masked to zero

    @_ == 1 or die "wrong number of arguments";

    return $_[0] & 0xff
} # }}}1

sub as_uint16 # {{{1
{
    # Return the argument with all bits higher than the 16th masked to zero
    @_ == 1 or die "wrong number of arguments";

    return $_[0] & 0xffff
} # }}}1

sub crc_ccitt_update # {{{1
{
    # Return a new version of the 16 bit CRC value given as the first
    # argument, produced using the 8 bit value given (as an integer) in the
    # second argument, in the manner described for the _crc_ccitt_update()
    # function from the util/crc16.h header of AVR libc.

    @_ == 2 or confess "wrong number of arguments";
    my ($crc, $bv) = @_;   # CRC Value, Byte Value

    ($crc & 0xffff0000) == 0 or die "initial CRC value more than 16 bits wide";
    looks_like_number($bv)
        or confess "bug: perl doesn't think byte value is a number here"; 
    ($bv & 0xffffff00) == 0 or die "byte value more than 8 bits wide";

    $bv ^= (0xff & $crc);
    $bv ^= 0x00ff & ($bv << 4);

    return (
        as_uint16(($bv << 8) | ((0xff00 & $crc) >> 8)) ^
        as_uint8($bv >> 4) ^
        as_uint16($bv << 3) );
} # }}}1

sysopen(UD, "$df", O_RDWR | O_SYNC)   # USB Device
    or die "sysopen() of device file '$df' for read/write failed: $!";

sub configure_tty # {{{1
{
    # Use the stty program to configure the serial device given as an
    # argument st we can send it raw data and it will get through to the
    # XBee unmolested.
    #
    # Its important to undertand that when the stdin and/or stdout of this
    # program are connected to a terminal, the existing settings for that
    # terminal still apply.  We're configuring the settings for the serial
    # connection to the XBee, NOT the ones for the terminal you type into.
    # Thus backspace and such still work.  All your input is resolved into
    # a single line then sent off to the XBee serial port.

    @_ == 1 or die "wrong number of arguments";
    my $df = shift;

    # I *think* this consolidated raw setting is what we want.  Serial port
    # configuration counts as a black art these days IMO.
    not system ("stty -F $df 9600 raw") or die "stty failed";
} # }}}1

my $mps = 100;   # XBees (Series 1 at least) Maximum (RF) Packet Size

my $xbro = 3;

sub send_single_packet # {{{1
{
    # Attempt to send data in the argument scalar to the XBee in such a
    # way that it goes out as a single radio packet (see BUGS AND POTENTIAL
    # WORK-AROUNDS in the POD for details).  Return "success" on success,
    # or a string beginning with "failure: " (followed by details of the
    # failure) on failure.  If a system call does something really unexpected,
    # die internally.

    @_ == 1 or die "wrong number of arguments";
    my $dts = shift;   # Data To Send

    # First slurp all the input data

    my $mps = 100;   # XBees (Series 1 at least) Maximum (RF) Packet Size
    my $dtsl = length($dts);   # Data To Send Length (non-utf8 handle required)
    if ( $dtsl > $mps ) {
        return "failure: got >$mps bytes (max radio packet size) of input";
    }

    # In theory, we could be checking the byte-to-byte times.  But that
    # would require sending the bytes in seperate syswrite() calls, which
    # is probably at least as likely to result in an unnaceptable delay,
    # since the OS is probably more likely to interrupt us between syswrite()
    # calls than during one.

    # But that introduces so many measurements.  This really conservative
    # approach seems safer to me somehow.

    # Now try to send it all real quick, so the XBee puts it one packet.
    my $st = time();   # Start Time
    my $swr = syswrite(UD, $dts, $dtsl);   # Syswrite Return
    defined($swr) or die "syswrite to $df failed: $!";
    $swr == $dtsl
        or die "syswrite didn't write the expected number of bytes to $df";
    my $et = time();

    # Timing calculations.  See BUGS AND POTENTIAL WORK-AROUNDS in the POD.
    my $bpp = 8.0;      # Bits Per Byte
    my $bps = 9600.0;   # Bits Per Second
    my $pts = $xbro * $bpp / $bps;   # Packetization Timeout in Seconds
    
    my $tmoe = 0.1;   # Time Margin Of Error

    # Did we make it fast enough?
    if ( $et - $st > $pts * (1.0 - $tmoe) ) {
        # It really might work next time, maybe OS won't interrupt us then :)
        return "failure: didn't get data written fast enough";
    }

    # Now we want to delay long enough to make sure a transmission is forced.
    # Here the factor of safely works the opposite direction of the one above,
    # since we want to ensure that a transmission does happen.  Its also
    # more conservative, since our estimation of what constitutes a single
    # "character time" is a bit on the conservative side.
    my $usps = 1000000;   # microSeconds Per Second
    my $ptfs = 1.5;   # Packetization Time Factor of Safety
    usleep($pts * $ptfs * $usps);

    return "success";
} # }}}1

# Frame related constants {{{1

# Special byte values
my $frame_delimiter = 0x7e;
my $escape          = 0x7d;   # This one is used in order to escape too :)
my $xon             = 0x11;
my $xoff            = 0x13;
my $xflfv           = 0xff;   # Xor'ed Frame Length Flag Value
my $nxflfv          = 0x00;   # Not Xor'ed Frame Length Flag Value
my $escape_modifier = 0x20;   # Escaped bytes are XOR'ed with this value

# Maximum field sizes and espansion factor
my $fdl   = 1;   # Frame Delimiter Length
my $flfl  = 2;   # Frame Length Field Length (including flag byte but not CRC)
my $fmcb  = 8;   # Frame Max Crc Bytes (after possible escaping)
my $fmpef = 2;   # Frame Maximum Payload Expansion Factor (due to escaping)

# Frame Safe Safe Payload Length
my $fsspl = $mps - $fdl - $flfl - $fmcb;

$fsspl == 89
    or die "frame safe safe payload length doesn't match documented value";

# Frame Safe Arbitrary Payload Length
my $fsapl = int($fsspl / $fmpef);

$fsapl == 44
    or die "frame safe arbitrary payload length doesn't match documented value";

# }}}1

sub needs_escaped # {{{1
{
    # Return true iff the given byte argument needs escaping in our
    # frame scheme.  Note that this function takes an character value
    # (i.e. something perl thinks is a number, not a short string).

    @_ == 1 or die "wrong number of arguments";
    my $bv = shift;

    my $ubm = 255;   # Unsigned Byte Maximum
    $bv <= $ubm or confess "argument isn't <= $ubm";

    return( 
        $bv == $frame_delimiter or
        $bv == $escape or
        $bv == $xon or
        $bv == $xoff );
} # }}}1

sub escaped_crc_bytes # {{{1
{
    # Given a 16 bit CRC, return a pack of two to four bytes containing the
    # escaped form of the CRC.

    @_ == 1 or die "wrong number of arguments";
    my $crc = shift;

    my $ecrc = '';   # Escaped CRC to be returned

    my $hb = (0xff00 & $crc) >> 8;   # High Byte
    my $lb = 0xff & $crc;   # Low Byte
    if ( needs_escaped($hb) ) {
        $ecrc .= pack("CC", $escape, $hb ^ $escape_modifier);
    } 
    else {
        $ecrc .= pack("C", $hb);
    }
    if ( needs_escaped($lb) ) {
        $ecrc .= pack("CC", $escape, $lb ^ $escape_modifier);
    } 
    else {
        $ecrc .= pack("C", $lb);
    }

    (length($ecrc) >= 2 and length($ecrc) <= 4)
        or die "escaped CRC doesn't appear to be between 2 and 4 bytes long";

    return $ecrc;
} # }}}1

sub frame # {{{1
{
    # Return a frame in the format described in wireless_xbee.h from the
    # given argument data.  Note that this function doesn't verify that the
    # frame is short enough to go in a single radio packet.
    
    @_ == 1 or die "wrong number of arguments";
    my $pd = shift;   # Payload Data

    my $crciv = 0xffff;   # CRC initial value for our CRC algorithm

    my $lcrc = $crciv;   # CRC of the delimiter and escaped length field bytes
    my $pcrc = $crciv;   # CRC of the escaped payload bytes

    my $fd = '';    # Frame Data
    my $epd = '';   # Escaped Payload Data
    
    # Compute escaped payload data and associated CRC {{{2
    for ( my $ii = 0 ; $ii < length($pd) ; $ii++ ) {
        my $cc = substr($pd, $ii, 1);   # Current Character
        if ( needs_escaped(ord($cc)) ) {
            $pcrc = crc_ccitt_update($pcrc, $escape);
            my $xored_bv = ord($cc) ^ $escape_modifier;
            $pcrc = crc_ccitt_update($pcrc, $xored_bv);
            $epd .= pack "CC", $escape, $xored_bv;
        }
        else {
            $pcrc = crc_ccitt_update($pcrc, ord($cc));
            $epd .= pack "C", vec($cc, 0, 8);
        }
    }
    # }}}2

    # Begin delimiter + length CRC calculation, add frame delimiter {{{2 

    $lcrc = crc_ccitt_update($lcrc, $frame_delimiter);    # Updata CRC
    $fd .= pack "C", $frame_delimiter;

    # }}}2
    
    my $dplbl = 3;   # Delimiter byte plus length field bytes total

    # Add the length field, update delimiter + length CRC {{{2

    my $xflfv  = 0xff;   # Xor'ed Frame Length Flag Value
    my $nxflfv = 0x00;   # Not Xor'ed Frame Length Flag Value

    my $epdl = length($epd);   # Escaped Payload Data Length

    my $lne = needs_escaped($epdl);   # Length Needs Escaped?

    my $efv = $lne ? $xflfv : $nxflfv;   # Escape Flag Value
    $lcrc = crc_ccitt_update($lcrc, $efv);    # Updata CRC

    # Possibly Xor'ed Length Value Itself
    my $pxlvi = $lne ? $epdl ^ $escape_modifier : $epdl;
    $lcrc = crc_ccitt_update($lcrc, $pxlvi);    # Update CRC

    my $lfb = pack("CC", $efv, $pxlvi);   # Length Field Bytes

    $fd .= $lfb;

    length($fd) == $dplbl or die "BUG: frame length not as expected";

     # }}}2

     my $elcrc_bytes = escaped_crc_bytes($lcrc);   # Escaped lcrc bytes
     my $epcrc_bytes = escaped_crc_bytes($pcrc);   # Escaped pcrc bytes

     $fd .= $elcrc_bytes;   # Add the escaped frame delimiter/lengch CRC bytes

     # Add the escaped payload data {{{2

     for ( my $ii = 0 ; $ii < length($epd) ; $ii++ ) {
         $fd .= pack("C", ord(substr($epd, $ii, 1)));
     }

     # }}}2

     $fd .= $epcrc_bytes;   # Add the escaped payload CRC bytes

     length($fd) == (
         $dplbl +
         length($elcrc_bytes) +
         $epdl +
         length($epcrc_bytes) )
         or die "BUG: frame length not as expected";

     return $fd;
} # }}}1

sub get_byte # {{{1
{
    # Read exactly one byte from the serial device.  Its wise to call
    # byte_available() first, to avoid potentially hanging forever.
    # Return the read byte as an integer.

    my $rd;           # Read Data
    my $rr = sysread(UD, $rd, 1);   # Read Return value
    defined($rr) or die "sysread failed on $df: $!";
    $rr == 1 or die "sysread() didn't read exactly one byte as expected";

    return ord($rd);
} # }}}1

sub high_byte # {{{1
{
    # Return the high byte of the given 16 bit value
    
    @_ == 1 or die "wrong number of arguments";
    my ($val16) = @_;

    ($val16 & 0xffff0000) == 0
        or die "BUG: supposed 16 bit argument has bits > 16 set";

    return ($val16 & 0xff00) >> 8;
} # }}}1

sub low_byte # {{{1
{
    # Return the low byte of the given 16 bit value
    
    @_ == 1 or die "wrong number of arguments";
    my ($val16) = @_;

    ($val16 & 0xffff0000) == 0
        or die "BUG: supposed 16 bit argument has bits > 16 set";

    return $val16 & 0x00ff;
} # }}}1

sub byte_available # {{{1
{
    # Return true iff a byte appears to be available to read from the
    # serial device.

    my ($rin, $rout, $ein, $eout) = ('', '', '', '');
    my $udfn = fileno(UD);
    vec($rin, $udfn, 1) = 1;

    my ($rfc, $tl) = select($rout = $rin, undef, $eout = $ein, 0);

    not vec($eout, $udfn, 1)
        or die "select() reported an exception related to file '$df'";

    if ( $rfc == 0 ) {
        return 0;
    }
    elsif ( $rfc == 1 ) {
        vec($rout, $udfn, 1)
            or die "BUG: file we expected to be readable isn't after select";
        return 1;
    }
    else {
        confess "BUG: unexpected ready file count from select()";
    }
} # }}}1

sub get_frame # {{{1
{
    # Like wx_get_frame() from wireless_xbee.c, but with a perlesque
    # signature.  Most of the explanatory comments are there.  Unlike that
    # function, this one gives some feedback when things go wrong: it
    # returns "success" on success, or a string beginning with "failure: "
    # on failure.  As arguments we require a ref to an empty string (where
    # the payload data will be stored) and a timeout value in milliseconds.
    # The timeout value is actually the time spent polling the serial port,
    # other code time isn't included (but is pretty negligible).

    @_ == 2 or die "wrong number of arguments";
    my ($pdr, $to) = @_;   # Payload Data Ref, Timeout

    # We return the string into a referenced scaler which must be undef or ''.
    not defined ($$pdr) or length($$pdr) == 0
        or die "defined payload data ref doesn't point to empty string";
    $$pdr = '';
    
    my $fs = "outside frame";   # Frame State
    my $crciv = 0xffff;         # CRC initial value for our CRC algorithm
    my $crc = $crciv;           # CRC value
    my $et = 0;                 # Elapsed Time (in milliseconds)
    my $epl;                    # Escaped Payload Length
    my $epbr = 0;               # Escaped Payload Bytes Read (so far)
    my $lxorfb;                 # Length XOR'ed Flag Byte

    # Note that we don't count the time executing code, just the time spent
    # sleeping between polls.  Its very close though.
    while ( $et < $to ) {
            
        if ( byte_available() ) {

            my $cb = get_byte();

            if ( $cb == $frame_delimiter ) {
                $crc = crc_ccitt_update($crc, $cb);
                if ( $fs ne "outside frame" ) {
                    return "failure: frame delimiter while not outside frame";
                }
                $fs = "at length xored flag";
            }

            else {
                if    ( $fs eq "at length xored flag" ) {
                    $crc = crc_ccitt_update($crc, $cb);
                    $lxorfb = $cb;
                    $lxorfb == $xflfv or $lxorfb == $nxflfv
                        or return "failure: invalid length xor'ed flag value";
                    $fs = "at length itself";
                }

                elsif ( $fs eq "at length itself" ) {
                    $crc = crc_ccitt_update($crc, $cb);
                    $epl = $cb;
                    if ( $lxorfb == $xflfv ) {
                        $epl ^= $escape_modifier;
                    }
                    $fs = "at length crc high byte";
                }

                elsif ( $fs eq "at length crc high byte" ) {
                    if ( $cb == $escape ) {
                        $fs = "at length crc high byte escaped";
                    }
                    else {
                        if ( $cb != high_byte($crc) ) {
                            return "failure: delimiter/length CRC error";
                        }
                        $fs = "at length crc low byte";
                    }
                }

                elsif ( $fs eq "at length crc high byte escaped" ) {
                    my $ucb = ($cb ^ $escape_modifier);   # Unescaped $cb
                    if ( $ucb != high_byte($crc) ) {
                        return "failure: delimiter/length CRC error";
                    }
                    $fs = "at length crc low byte";
                } 

                elsif ( $fs eq "at length crc low byte" ) {
                    if ( $cb == $escape ) {
                        $fs = "at length crc low byte escaped";
                    }
                    else {
                        if ( $cb != low_byte($crc) ) {
                            return "failure: delimiter/length CRC error";
                        }
                        $crc = $crciv;   # Reset for later use on payload
                        $fs = "in payload";
                    }
                }

                elsif ( $fs eq "at length crc low byte escaped" ) {
                    my $ucb = ($cb ^ $escape_modifier);   # Unescaped $cb
                    if ( $ucb != low_byte($crc) ) {
                        return "failure: delimiter/length CRC error";
                    }
                    $crc = $crciv;   # Reset for later use on payload
                    $fs = "in payload";
                }

                elsif ( $fs eq "in payload" ) {
                    $crc = crc_ccitt_update($crc, $cb);
                    if ( $cb == $escape ) {
                        $fs = "in payload escaped";
                    }
                    else {
                        $$pdr .= chr($cb);
                    }
                    $epbr++;
                    if ( $epbr == $epl ) {
                        $fs = "at payload crc high byte";
                    }
                }

                elsif ( $fs eq "in payload escaped" ) {
                    $crc = crc_ccitt_update($crc, $cb);
                    $$pdr .= chr($cb ^ $escape_modifier);
                    $epbr++;
                    if ( $epbr == $epl ) {
                        $fs = "at payload crc high byte";
                    }
                    else {
                        $fs = "in payload";
                    }
                }

                elsif ( $fs eq "at payload crc high byte" ) {
                    if ( $cb == $escape ) {
                        $fs = "at payload crc high byte escaped";
                    }
                    else {
                        if ( $cb != high_byte($crc) ) {
                            return "failure: payload CRC error";
                        }
                        $fs = "at payload crc low byte";
                    }
                }

                elsif ( $fs eq "at payload crc high byte escaped" ) {
                    my $ucb = ($cb ^ $escape_modifier);   # Unescepd $cb
                    if ( $ucb != high_byte($crc) ) {
                        return "failure: payload CRC error";
                    }
                    $fs = "at payload crc low byte";
                } 

                elsif ( $fs eq "at payload crc low byte" ) {
                    if ( $cb == $escape ) {
                        $fs = "at payload crc low byte escaped";
                    }
                    else {
                        if ( $cb != low_byte($crc) ) {
                            return "failure: payload CRC error";
                        }
                        return "success";
                    }
                }

                elsif ( $fs eq "at payload crc low byte escaped" ) {
                    my $ucb = ($cb ^ $escape_modifier);   # Unescepd $cb
                    if ( $ucb != low_byte($crc) ) {
                        return "failure: payload CRC error";
                    }
                    return "success";
                }
            }
        }

        else {
            my $poll_interval_ms = 1;   # Poll interval in milliseconds
            my $uspms = 1000;   # MicroSeconds Per MilliSecond
            usleep($poll_interval_ms * $uspms);
            $et += $poll_interval_ms;   # Elapsed time
        }
    }

    return "failure: timed out before receiving full (possibly any of) frame";
} # }}}1

configure_tty($df);

sub almost_random_payload # {{{1
{
    # Produce a almost random payload that includes no newlines except a
    # single one as the last byte.

    my $result = '';
   
    # Constants as dictated by our frame format and documented in usb_xbee
    my $fsspl = 89;   # Frame Safe Safe Payload Length
    my $fsapl = 44;   # Frame Safe Arbitrary Payload Length
    # FIXME: debug
    #my $fsapl = 4;   # Frame Safe Arbitrary Payload Length

    my $ps = $fsapl;
    # We can also test safe payloads of the maximum size using this line
    # instead but then the rotation distance setting in almost_rotate_bytes()
    # should be tweaked to not actually rotate, and the code below in the for
    # loop in this function changes to produce only safe payload characters
    # (zero through nine for example).
    #my $ps = $fsspl;

    for ( my $ii = 0 ; $ii < $ps - 1 ; $ii++ )  {

        # Other options include "zero through nine" and "printable chars"
        # (including '}' which exercises escaping in our frame scheme).
        my $tdt = "general bytes";       # Test Data Type
        #my $tdt = "printable chars";     # Test Data Type
        #my $tdt = "zero through nine";   # Test Data Type

        if ( $tdt eq "general bytes") {
            # Compute payload that's random except for no newlines
            my $mubv = 255;   # Maximum Unsigned Byte Value
            my $eps = 0.00001;
            my $rand_max = 255.0 - $eps;   # - $eps due to how perl rand() works
            my $pnb;   # Potential Next Byte (as character)
            do {
                $pnb = chr(int(rand($rand_max)));
            } until ( $pnb ne "\n" );
            $result .= $pnb;
        }
        elsif ( $tdt eq "printable chars" ) {
            my $eps = 0.00001;
            my $nc = chr(int(rand(126 - 33 - $eps)) + 33);   # New Char
            $result .= $nc;
        }
        elsif ( $tdt eq "zero through nine" ) {
            $result .= chr(int(rand(9.999)) + 48);
        }
    }

    $result .= "\n";   # Add a single newline at the end

    return $result;
} # }}}1

while ( 1 ) {
    # FIXME: WORK POINT: ok, we can send foo foo foo, but the almost
    # random payload fails about as soon as the pro version, so maybe its
    # semi-isolated here.
    #my $msg_out = "foo foo foo\n";
    #my $msg_out = "1111111111222222222233333333334444444444555\n";
    my $msg_out = almost_random_payload();
    my $frame_out = frame($msg_out);

    print "About to write to XBee\n";
    (syswrite(UD, $frame_out) == length($frame_out)) or die "write failed";
    print "written\n";

    my $msg_in;

    for ( ; ; ) { byte_available() and last; }
    my $result = get_frame(\$msg_in, 1000);
    #print "get_frame result: $result\n";
    $result eq 'success' or die "get_frame() failed";
    #print "msg_in: $msg_in\n";
    my ($mil, $mol) = (length($msg_in), length($msg_out));
    $mil == $mol or die "message lengths are different: mil: $mil, mol: $mol";
    $msg_in eq $msg_out or die "message in ne to message out";
    print "round tripped worked\n";
    #sleep 1;
}
