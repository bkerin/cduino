#!/usr/bin/perl -w

# This program lets you easily talk to an XBee module using a serial-over-USB
# adapter.  See the POD documentation for more hardware details:
#
#   pod2text usb_xbee

# vim:foldmethod=marker

# Pragmas and Modules {{{1

use strict;
use warnings FATAL => 'all';

use Fcntl;
use Getopt::Long qw( GetOptions );
use IO::Handle;
use Pod::Usage qw( pod2usage );
use Time::HiRes qw( time );

# }}}1

# POD (Plain Old Documentation) {{{1

=head1 NAME

usb_xbee - configure and transmit/receive data via a USB XBee device

=head1 SYNOPSIS

B<usb_xbee> --device=I<DEVICE> --command-mode

B<usb_xbee> --device=I<DEVICE> --raw-mode

B<usb_xbee> --device=I<DEVICE> --framed-lines-mode

=head1 DESCRIPTION

Usage is simple: start the program and start typing commands without their "AT"
prefixes (if --command-mode), or data (if --raw-mode), or something slightly
more elaborate (if --framed-lines-mode).  Of course you can also use pipes or
shell redirects to supply data and store output.

You need both an XBee module and an adapter to talk to it over USB.

I've successfully tried this program with the following adapters:

=over 4

=item *

Sparkfun XBee Explorer USB (Sparkfun part number WRL-08687).  Make sure to get
a USB Type A to USB Mini-B cable as well, it isn't included.

=item *

Sparkfun XBee Explorer Dongle (Sparkfun part number WRL-09819).

=item *

A random older USB dongle from Smiley Micros.

=back

I've succesfully tried this program with the following modules:

=over 4

=item *

Series 1 XBee 1mW Chip Antenna Module (Sparkfun part number WRL-08664),
firmware version 10E6 (the version that ships with the module, at least for
me).

=item *

Series 1 XBee 1mW Trace Antenna Module (Spartfun part number WRL-11215),
firmware version 10EC (the version that came on the module, at least for me).

=back

Some other modules will likely work as well, though I tried an old XBee Pro
from 2006 and it didn't work (couldn't get into command mode).  Series 2.5, ZB,
and 2B modules probably won't work outof the box, but might with appropriate
firmware installed.  I don't know on the 900 MHz, XSC or XSC S3B modules.  See
this page for more information of the different module families:

https://www.sparkfun.com/pages/xbee_guide

On my system at least, it takes a surprisingly long time (10 - 20 seconds) for
the module device file to become usable the first time the module is plugged
in.  This program will fail with an error during this time.  I assume there's
a kernel module that gets loaded or something.

=head1 OPTIONS AND ARGUMENTS

=over 4

=item B<-d> I<DEVICE>, B<-device>=I<DEVICE>

Specify the device file corresponding to the connected XBee module (e.g.
"/dev/ttyUSB0").  It may be easist to find the correct device file in /dev by
watching for it to appear when the device is plugged in.  Try this command:

  ls -1 /dev >/tmp/oe; \
  echo -n Plug in or unplug device then hit enter; \
  read; \
  sleep 1; \
  ls -1 /dev >/tmp/ne; diff /tmp/oe /tmp/ne \
    | grep -E '(\+|\-)[[:alpha:]]' \
    | cut --bytes=2-
  || ( echo error: did not detect and change in /dev contents 1>&2 \
       && false )

Note that the device file name is probably dynamically assigned and might
change depending on what hardware you have plugged in and also on the order in
which you plugged it in.

=item B<-c>, B<--command-mode>

Enter command mode on startup by sending the sleep-bracketed '+++' AT command
initiation sequence.  Then enable a convenient keep-alive feature and few
tranformations on input and output:

=over 4

=item *

If there is no input for a few seconds, sent an "AT\r" string to the
XBee module to prevent it from automatically dropping out of command mode.
Neither this command nor the corresponding returned string are shown on this
program's stdin/stdout.

=item *

Input lines first have leading or trailing white space removed, then
"AT" added as a prefix, and "\r" added as a suffix.

=item *

All input characters are translated to upper case (even though most
if not all XBees are not case sensitive).

=item *

Output lines have "\r" characters replaced with "\n" characters.

=back

Note that if this program exits abnormally (i.e. other than by getting EOF on
its stdin due to Cntrl-D being pressed), the XBee module will remain in command
mode for up to 10 seconds after the last command is issued (unless an explicit
exit-command-mode command ("CN") is issued).

=item B<-r>, B<--raw-mode>

Raw mode.  In this mode, bytes from the standard input may be line-buffered (if
stdin is connection to a terminal) but are otherwise sent unmodified to the
XBee, and data sent to us from the XBee is passed unmodified to our standard
output.

There are some caveats related to RF packetization in raw mode, see the
L<BUGS AND POTENTIAL WORK-AROUNDS> section.

=item B<-p>, B<--framed-lines-mode>

WARNING: for this mode to perform as advertised, you must first use command
mode to ensure that the packetization timeout configuration parameter is set to
its maximum (0xFF), for example if your I<DEVICE> is /dev/ttyUSB0:

  echo -e -n "ROFF\nWR\n" | ./usb_xbee -d /dev/ttyUSB0 -c

This mode is like raw mode, but it attempts to send each newline or end-of-file
terminated line of input as a single frame in the format described in
wireless_xbee.h (see the wx_put_data_frame() in that file).  If an escaped line
is too long (longer than 100 bytes) to transmit as a single frame, or if the
timing requirements for single-packet transmission aren't met, this program
prints an error message and exits with a non-zero exit code.  See
L<BUGS AND POTENTIAL WORK-AROUNDS> for more details.

Received data is assumed to consist of frames in the same format (the payloads
of which are printed to stdout as in raw mode).  Incoming data which doesn't
cannot be interpreted as part of a frame will result in an error and exit with
a non-zero exit code.

=back

=head1 BUGS AND POTENTIAL WORK-AROUNDS

XBee series 1 modules (and probably other XBees also) in their default
"transparent" mode depend on the timing of data coming in from the serial port
to decide when to packetize and transmit an RF packet.  They do so every time
they get 100 bytes, or when some particular (configurable) amount of time
passes without any additional bytes being queued for transmission.

# FIXME: WORK POINT: updating for switch to frames here

In a microcontroller context this is a reasonable approach: its easy to ensure
that all the bytes in a short message are transmitted in quick succession,
thereby guaranteeing that they will be grouped into a single atomic RF packet
and make it to the receivers without being interleaved with other data.
For an XBee connected to a computer via USB, it's more problematic because its
more difficult to ensure that the byte stream for a packet is continuous.

In raw mode, this program normally ignores the problem.  Data coming from stdin
is line buffered (mainly for convenience when testing things out from the
terminal), so its likely to end up packetized into individual lines, but
there's no guarantee of this (but see the --packetize-lines option).  For
simple testing with a single transmitter and no possibility of collisions,
this doesn't matter.

If on the other hand you're trying to use this program for something real, you
have a few options:

=over 4

=item * 

Increase the XBee packetization timeout to the maximum 0xFF (using AT command
RO, e.g. "ROFF" probably followed by "WR" in command mode), and use the
--single-packet-mode or --raw-mode and --packetize-lines options.

When attempting to transmit a single packet, this program measures the time
required to send an entire prospective packet of up to 100 bytes using perl's
Time::Hires module.  If the entire transmission took less than 0xFF (256)
"character times" (as the XBee Manual likes to call them), then its probably
reasonable to assume the entire chunk of data was lumped into a single RF
packet.  One "character time" at 9600 baud is probably at least 833
microseconds:

  (8 bits per byte) * (1 / 9600 bits per second) = 0.000833 seconds per byte

Note: this is apparently one of the many contexts in which "baud" is
incorrectly used to mean "bps".

One "character time" could be a bit longer (do we include stop start/stop
bits?), but this is the conservative interpretation.  See
http://www.labbookpages.co.uk/electronics/serialPort.html for details.

I've tested these options in the presense of continuous byte-at-a-time traffic
from a second source (a second XBee with RO set to 0x00, indicating
send-at-once operation), and it "seems to work" (TM).  FIXME: and maxstream
says it should?  FIXME: MaxStream bps thing?  That is, the receiver (a third
XBee) didn't see any cases where the incoming packet was interleaved with data
from the byte-at-a-time source.  However...

The measured time to syswrite() the data to the serial port is also much
shorter than would be possible for the actual transmission of the bytes to the
hardware serial port on the sending XBee at 9600 baud: it typically takes less
than 25 microseconds on my system.  This isn't really too surprising, since we
aren't actually sending it to the serial port, but rather to the USB port which
is connected to an FTDI FT232RL (or similar) chip that in turn sends the data
on to the serial port.  The FT232RL is a USB 2.0 480 Mb/s device (making the
above 25 microsecond value quite plausible as a transfer time) and presumably
has a buffer of its own that is capable of absorbing high-speed bursts of data
from the USB side.

The FT232RL has no reason to hang onto the data, and if it makes it that far
its probably safe to assume in gets to the XBee fast enough to meet the timing
requirements.  

Then again, perhaps the OS-side kernel squirrels the data away in a buffer of
its own (despite the O_SYNC option having been used when the device file was
opened).  In that case, the OS might subsequently be interrupted in such a way
that the data doesn't make it out as a single RF packet afterall.  Our timer
will fail to detect this failure :(
FIXME: investigate this issue.

=item *

Use API mode rather than transparent mode on the XBee.  You're on your own
here, though command mode can still be used to configure things, and raw mode
can be used to assemble data frames.

=item *

Do nothing at the tranmission end, and deal with interleaved data at
the receivers (reinvent ethernet :)

=back

=head1 AUTHOR

Britton Kerin (britton.kerin@gmail.com)

=cut

# }}}1

# This normally commented out block is useful for verifying (at least
# somewhat) that our CRC calculation works the same in perl as in C.
# See the comments in the ccitt.c source file.
#{ # {{{1
#    my $data_size = 100000;
#    my @data = (1 .. $data_size);
#    my $crc = 0xffff;
#    my $uint8_max = 255;
#    foreach ( @data ) {
#        $crc = crc16_ccitt_update($crc, ($_ % ($uint8_max + 1)));
#        printf "New crc: %.4X\n", $crc
#    }
#    exit (0);
#} # }}}1

# Process Command Line Options/Arguments {{{1

my $help;   # True iff we should just print usage information and exit
my $df;     # Device File
my $cm;     # Command Mode
my $rm;     # Raw Mode
my $pl;     # Packetized Lines
my $sm;     # Single packet Mode

GetOptions(
    "help|?"               => \$help,
    "device-file|d=s"      => \$df,
    "command-mode|c"       => \$cm,
    "raw-mode|r"           => \$rm,
    "packetize-lines|p"   => \$pl,
    "single-packet-mode|s" => \$sm )
    or die "usb_xbee: GetOptions failed, try usb_xbee --help\n";

if ( $help ) {
    pod2usage(-verbose => 1, -exitval => 0);
}

$df or die "--device-file option must be given";

($cm xor $rm xor $sm)
    or die "exactly one of --command-mode, --raw-mode or --single-packet-mode ".
           "options must be given";

# }}}1

if ( not $sm ) {
  # We probably don't really need O_SYNC here, but it shouldn't hurt.
  sysopen(UD, "$df", O_RDWR | O_SYNC)   # USB Device
      or die "couldn't sysopen device file '$df' for read/write: $!";
}
else {
  sysopen(UD, "$df", O_WRONLY | O_SYNC)   # USB Device
      or die "couldn't sysopen device file '$df' for reading: $!";

}

sub configure_tty # {{{1
{
    # Use the stty program to configure the serial device given as an
    # argument st we can send it raw data and it will get through to the
    # XBee unmolested.
    #
    # Its important to undertand that when the stdin and/or stdout of this
    # program are connected to a terminal, the existing settings for that
    # terminal still apply.  We're configuring the settings for the serial
    # connection to the XBee, NOT the ones for the terminal you type into.
    # Thus backspace and such still work.  All your input is resolved into
    # a single line then sent off to the XBee serial port.

    @_ == 1 or die "wrong number of arguments";
    my $df = shift;

    # I *think* this consolidated raw setting is what we want.  Serial port
    # configuration counts as a black art these days IMO.
    not system ("stty -F $df 9600 raw") or die "stty failed";
} # }}}1

sub get_response # {{{1
{
    # Get a response to an AT command (which we assume was previously sent),
    # or die if we get nothing for too long or too much garbage.  The trailing
    # '\r' character which signals the end of the response is returned with
    # the rest of the response.

    my $rt = '';   # Response Text 

    # Maximum Response Length.  If we don't see the "\r" within this many
    # characters, something is wrong.
    my $mrl = 20;

    # Timeout Time.  If we don't see the "\r" within this many seconds,
    # something is wrong.
    my $tt  = 5; 

    # Set an alarm so we'll die instead of hanging forever if we don't get
    # a response.
    $SIG{ALRM}
        = sub
          {
              die "invalid command response: no \"\\r\" within $tt ".
                  "seconds.  Perhaps we exited command mode somehow?";
          };
    alarm($tt);

    for ( my $ii = 0 ; $ii < $mrl ; $ii++ ) {

        my $rr = sysread(UD, $rt, 1, $ii);   # Read Return value
        defined($rr)
            or die "sysread failed on $df: $!.  Perhaps we exited command ".
                   "mode somehow?";
        $rr == 1
            or die "failed to read exactly one character from $df.  Perhaps ".
                   "we exited command mode somehow?";

        if ( substr($rt, $ii, 1) eq "\r" ) {

            # Cancel the alarm
            alarm(0);
            $SIG{ALRM} = 'DEFAULT';

            return $rt;
        }
    }

    # Cancel the alarm
    alarm(0);
    $SIG{ALRM} = 'DEFAULT';

    die "didn't get command response with trailing '\r' within $mrl bytes.  ".
        "Perhaps we exited command mode somehow?";
} # }}}1

sub enter_command_mode # {{{1
{
    # Perform the wait-one-second, send-+++, wait-1-second sequence required
    # to go into command mode, and wait for the result indicating it worked
    # (dying if we don't get it).

    sleep 1;
    my $swr = syswrite(UD, '+++');   # SysWrite Return
    defined($swr)
        or die "syswrite to $df failed: $!";
    $swr == length('+++')
        or die "syswrite didn't write the expected number of bytes to $df";
    sleep 1;

    get_response() eq "OK\r" or die "failed to enter command mode";
} # }}}1

sub leave_command_mode # {{{1
{
    # Leave command mode by issuing the AT command that leaves command mode.

    my $ecmcs = "ATCN\r";   # Exit Command Mode Command String

    my $swr = syswrite(UD, $ecmcs);   # SysWrite Return
    defined($swr)
        or die "syswrite to $df failed: $!";
    $swr == length($ecmcs)
        or die "syswrite didn't write the expected number of bytes to $df";

    get_response() eq "OK\r" or die "failed to leave command mode";
} # }}}1

sub timed_wait_for_stdin # {{{1
{
    # Wait up to the given number of seconds for STDIN to have something we
    # can read.  Return true iff it does.

    @_ == 1 or die "wrong number of arguments";
    my $to = shift;   # Timout, in seconds

    my $rin = '';
    my $rout = '';
    my $sifn = fileno(STDIN);
    vec($rin, $sifn, 1) = 1;
    my $rfc = select($rout = $rin, undef, undef, 2);   # Ready File Count
    $rfc != -1 or die "select failed: $!";
    $rfc == 0 or $rfc == 1
        or die "select indicated an unexpected number of ready files";
    if ( $rfc == 1 ) {
        vec($rout, $sifn, 1) == 1
            or die "select doesn't indicate the expected ready file set";
        return 1;
    }
    else {
        return 0;
    }
} # }}}1

my $mps = 100;   # XBees (Series 1 at least) Maximum (RF) Packet Size

sub send_single_packet # {{{1
{
    # Attempt to send data in the argument scalar to the XBee in such a
    # way that it goes out as a single radio packet (see BUGS AND POTENTIAL
    # WORK-AROUNDS in the POD for details).  Return "success" on success,
    # or a string beginning with "failure: " (followed by details of the
    # failure) on failure.  If a system call does something really unexpected,
    # die internally.

    @_ == 1 or die "wrong number of arguments";
    my $dts = shift;   # Data To Send

    # First slurp all the input data

    my $mps = 100;   # XBees (Series 1 at least) Maximum (RF) Packet Size
    my $dtsl = length($dts);   # Data To Send Length (non-utf8 handle required)
    if ( $dtsl > $mps ) {
        return "failure: got >$mps bytes (max radio packet size) of input";
    }

    # In theory, we could be checking the byte-to-byte times.  But that
    # would require sending the bytes in seperate syswrite() calls, which
    # is probably at least as likely to result in an unnaceptable delay,
    # since the OS is probably more likely to interrupt us between syswrite()
    # calls than during one.

    # But that introduces so many measurements.  This really conservative
    # approach seems safer to me somehow.

    # Now try to send it all real quick, so the XBee puts it one packet.
    my $st = time();   # Start Time
    my $swr = syswrite(UD, $dts, $dtsl);   # Syswrite Return
    defined($swr) or die "syswrite to $df failed: $!";
    $swr == $dtsl
        or die "syswrite didn't write the expected number of bytes to $df";
    my $et = time();

    # Timing calculations.  See BUGS AND POTENTIAL WORK-AROUNDS in the POD.
    my $ptb = 0xFF;   # Packetization Timeout in Bytes
    my $bpp = 8;      # Bits Per Byte
    my $bps = 9600;   # Bits Per Second
    my $tr = $ptb * $bpp / $bps;   # Time Requirement (minimum time to send)
    
    my $tmoe = 0.1;   # Time Margin Of Error

    # Did we make it fast enough?
    if ( $et - $st > $tr * (1.0 - $tmoe) ) {
        # It really might work next time, maybe OS won't interrupt us then :)
        return "failure: didn't get data written fast enough";
    }

    return "success";
} # }}}1

sub as_uint8 # {{{1
{
    # Return the argument with all bits higher than the 8th masked to zero

    @_ == 1 or die "wrong number of arguments";

    return $_[0] & 0xff
} # }}}1

sub as_uint16 # {{{1
{
    # Return the argument with all bits higher than the 16th masked to zero
    @_ == 1 or die "wrong number of arguments";

    return $_[0] & 0xffff
} # }}}1

sub crc16_ccitt_update # {{{1
{
    # Return a new version of the 16 bit CRC value given as the first
    # argument, produced using the 8 bit value given as the second argument,
    # in the manner described for the _crc_ccitt_update() function from the
    # util/crc16.h header of AVR libc.

    @_ == 2 or die "wrong number of arguments";
    my ($crc, $bv) = @_;   # CRC Value, Byte Value

    ($crc & 0xffff0000) == 0 or die "initial CRC value more than 16 bits wide";
    ($bv  & 0xffffff00) == 0 or die "byte value more than 8 bits wide";

    $bv ^= (0xff & $crc);
    $bv ^= 0x00ff & ($bv << 4);

    return (
        as_uint16(($bv << 8) | (0xff00 & $crc)) ^
        as_uint8($bv >> 4) ^
        as_uint16($bv << 3) );
} # }}}1

# FIXME: remove this junk once crc is tested
#   uint16_t
#    crc_ccitt_update (uint16_t crc, uint8_t data)
#    {
#        data ^= lo8 (crc);
#        data ^= data << 4;
#
#        return ((((uint16_t)data << 8) | hi8 (crc)) ^ (uint8_t)(data >> 4) 
#                ^ ((uint16_t)data << 3));
#    }
## uint16_t
#    crc16_update(uint16_t crc, uint8_t a)
#    {
#        int i;
#
#        crc ^= a;
#        for (i = 0; i < 8; ++i)
#        {
#            if (crc & 1)
#                crc = (crc >> 1) ^ 0xA001;
#            else
#                crc = (crc >> 1);
#        }
#
#        return crc;
#    }

configure_tty($df);

if ( $cm ) {   # Command Mode {{{1

    enter_command_mode();

    my $ki = 4;   # Keepalive Interval (seconds)

    for ( ; ; ) {

        my $gsi = timed_wait_for_stdin($ki);   # Got Standard Input?
        my $cts;   # Command To Send

        if ( $gsi ) {
            # Get the line of input
            $cts = STDIN->getline();
            not STDIN->error() or die "error reading line from STDIN";
            # Now undef means we must have got EOF (possibley from Cntrl-D),
            # so we're done
            defined($cts) or (leave_command_mode() and exit(0));
        }
        else {
            # Note that we'll add the AT and "\r" as for normal commands
            $cts = '';
        }

        # Transform input line as promised
        $cts =~ s/\s*(.*)\s*/$1/;    # Strip leading/trailing white space
        $cts =~ tr/a-z/A-Z/;         # Translate to upper case
        $cts = "AT".$cts."\r";       # Add leading "AT" and trailing "\r"

        # Send stuff to the XBee
        my $swr = syswrite(UD, $cts);
        defined($swr) or die "syswrite failed: $!";
        $swr == length($cts)
            or die "syswrite didn't write the expected number of bytes";

        my $rl = get_response();   # Response Line (from XBee)

        if ( $gsi ) {
            # Transform output line as promised
            $rl =~ s/\r$/\n/
                or die "command response didn't end with a carriage return";

            # Display the output
            print $rl or die "print() (to stdout) failed";
        }
        else {
            $rl eq "OK\r"
                or die "didn't get OK response to empty keep-alive commmand";
        }
    }
} # }}}1

elsif ( $rm ) {   # Raw Mode {{{1

    # In raw mode we can't depend no synchronous responses from the XBee:
    # data could come in at any time, and when it does we want to get it to
    # our stdout ASAP.  At the same time, we want to allow the user to supply
    # data on stdin.  So we select() on both of these potential inputs and
    # move data appropriately as it comes in.

    my ($rin, $rout, $ein, $eout) = ('', '', '', '');
    my $sifn = fileno(STDIN);
    my $udfn = fileno(UD);
    vec($rin, $sifn, 1) = 1;
    vec($rin, $udfn, 1) = 1;

    for ( ; ; ) {

        # Find any inputs that have data (or exceptions) ready for us
        my ($rfc, $tl) = select($rout = $rin, undef, $eout = $ein, undef);
        $rfc != -1 or die "select failed: $!";
        ($rfc >= 0 and $rfc <= 2)
            or die "select indicated an unexpected number of ready files";

        # Check for and report any input exceptions
        if ( vec($eout, $udfn, 1) ) {
            die "select() reported an exception related to file '$df'";
        }
        if ( vec($eout, $sifn, 1) ) {
            die "select() reported an exception related to stdin";
        }

        # For each ready input...
        for ( my $ii = 0 ; $ii < $rfc ; $ii++ ) {

            # If it's data from the XBee module, send it to our stdout
            if ( vec($rout, $udfn, 1) ) {
                my $btrao = 16;   # Bytes To Read At Once (maximum)
                my $rd;           # Read Data
                my $rr = sysread(UD, $rd, $btrao);   # Read Return value
                defined($rr) or die "sysread failed on $df: $!";
                $rr >= 1 or
                    die "sysread() read 0 bytes despite select() saying it ".
                        "had data ready to read";
                print $rd or die "print() (to stdout) failed";
                STDOUT->flush();   # Flush output (avoid line buffering)
            }

            # If it's data from stdin, send it to the XBee module
            if ( vec($rout, $sifn, 1) ) {
                # Note: using getline() means that we may end up sending
                # binary data in funny-sized chunks (because we probably
                # send both on newline and when the stdin buffer gets full).
                # When stdin is connected to a terminal it's convenient, but
                # it could have surprising effects on packetization for binary
                # data (see BUGS AND POTENTIAL WORK-AROUNDS in the POD).
                # FIXXME: this getline() seems to works slightly different
                # than the terminal and probably other GNU readline and
                # possibly other input functions with respect to EOF (Cntrl-D)
                # inputs: when Cntrl-D is typed on a non-empty line, nothing
                # whatsoever happens (rather than the existing text on the line
                # getting returned).  On empty lines its behaves as expected.
                # Not worth fixing.
                my $dts = STDIN->getline();   # Data To Send
                not STDIN->error() or die "error reading line from STDIN";
                # Now undef means we must have got EOF on an empty line
                # (possibly from Cntrl-D), so we're done
                defined($dts) or exit(0);
                if ( $pl ) {
                    my $sr = send_single_packet($dts);
                    if ( $sr eq "failure: got >$mps bytes (max radio packet ".
                                "size) of input" ) {
                        warn "got more than $mps bytes in one line, can't ".
                             "send that as a single packet, so not sending it";
                    }
                    elsif ( $sr eq "failure: didn't get data written fast ".
                                   "enough" ) {
                        warn "didn't get data written fast enough to feel ".
                             "confident it will go out as a single RF packet, ".
                             "maybe better luck next time :)";
                    }
                    elsif ( $sr eq "success" ) {
                        print STDERR "line packetized successfully\n";
                        ; # Do nothing on success
                    }
                    else {
                        die "BUG: unrecognized send_single_packet() return ".
                            "value";
                    }
                }
                else {
                    my $swr = syswrite(UD, $dts);   # SysWrite Return
                    defined($swr) or die "syswrite to $df failed: $!";
                    $swr == length($dts)
                        or die "syswrite didn't write the expected number of ".
                               "bytes to $df";
                }
            }
        }
    }

} # }}}1

elsif ( $sm ) {   # Single Packet Mode {{{1

    # First slurp all the input data
    my $dts = '';
    while ( <STDIN> ) {
      $dts .= $_; 
    }

    my $sr = send_single_packet($dts);   # Send Result

    if ( $sr eq "failure: got >$mps bytes (max radio packet size) of input" ) {
        die "got more than $mps bytes (XBee's maximum packet size) on stdin ".
            "in single-packet-mode";
    }
    elsif ( $sr eq "failure: didn't get data written fast enough" ) {
        die "didn't get data written fast enough to feel confident it will ".
            "go out as a single RF packet, maybe better luck next time :)";
    }
    elsif ( $sr eq "success" ) {
        ;   # Do nothing on success
    }
    else {
        die "BUG: unrecognized send_single_packet() return value";
    }

} # }}}1

else {
    die "shouldn't be here";
}

exit 0;
