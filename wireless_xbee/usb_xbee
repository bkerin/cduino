#!/usr/bin/perl -w

# This program lets you easily talk to an XBee module using a serial-over-USB
# adapter.  See the POD documentation for more hardware details:
#
#   pod2text usb_xbee

# vim:foldmethod=marker

# FIXME: WORK POINT: could show how to send a file in an example

# Pragmas and Modules {{{1

use strict;
use warnings FATAL => 'all';

use Fcntl;
use Getopt::Long qw( GetOptions );
use IO::Handle;
use Pod::Usage qw( pod2usage );

# }}}1

# POD (Plain Old Documentation) {{{1

=head1 NAME

usb_xbee - configure and transmit data via a USB XBee device

=head1 SYNOPSIS

B<usb_xbee> --device=I<DEVICE> --command-mode

B<usb_xbee> --device=I<DEVICE> --raw-mode

=head1 DESCRIPTION

Usage is simple: start the program and start typing commands without their "AT"
prefixes (if --command-mode) or data (if --raw-mode).  Of course you can also
use pipes or shell redirects to supply data and store output.  However...

You need both an XBee module and an adapter to talk to it over USB.

I've successfully tried this program with the following adapters:

=over 4

=item * Sparkfun XBee Explorer USB (Sparkfun part number WRL-08687).  Make sure
to get a USB Type A to USB Mini-B cable as well, it isn't included.

=item * Sparkfun XBee Explorer Dongle (Sparkfun part number WRL-09819).

=item * A random older USB dongle from Smiley Micros.

=back

I've succesfully tried this program with the following modules:

=over 4

=item * Series 1 XBee 1mW Chip Antenna Module (Sparkfun part number WRL-08664),
firmware version 10E6 (the version that ships with the module, at least for
me).

=item * Series 1 XBee 1mW Trace Antenna Module (Spartfun part number WRL-11215),
firmware version 10EC (the version that came on the module, at least for me).

=back

Some Other modules will likely work as well, though I tried an old XBee Pro
from 2006 and it didn't work.  Series 2.5, ZB, and 2B modules probably won't
work outof the box, but might with appropriate firmware installed.  I don't
know on the 900 MHz, XSC or XSC S3B modules.  See this page for more
information of the different module families:

https://www.sparkfun.com/pages/xbee_guide

On my system at least, it takes a surprisingly long time (10 - 20 seconds) for
the module device file to become usable the first time the module is plugged
in.  I assume there's a kernel module that gets loaded or something.

=head1 OPTIONS AND ARGUMENTS

=over 4

=item B<-d> I<DEVICE>, B<-device>=I<DEVICE>

Specify the device file corresponding to the connected XBee module (e.g.
"/dev/ttyUSB0").  It may be easist to find the correct device file in /dev by
watching for it to appear when the device is plugged in.  Try this command:

  ls -1 /dev >/tmp/oe; \
  echo -n Plug in or unplug device then hit enter; \
  read; \
  sleep 1; \
  ls -1 /dev >/tmp/ne; diff /tmp/oe /tmp/ne \
    | grep -E '(\+|\-)[[:alpha:]]' \
    | cut --bytes=2-
  || ( echo error: did not detect and change in /dev contents 1>&2 \
       && false )

Note that the device file name is probably dynamically assigned and might
change depending on what hardware you have plugged in and possibly also on the
order in which you plugged it in.

=item B<-c>, B<--command-mode>

Enter command mode on startup by sending the sleep-bracketed '+++' AT command
initiation sequence.  Then enable a convenient keep-alive feature and few
tranformations on input and output:

=over 4

=item * If there is no input for a few seconds, sent an "AT\r" string to the
XBee module to prevent it from automatically dropping out of command mode.
Neither this command nor the corresponding returned string are shown on this
program's stdin/stdout.

=item * Input lines first have leading or trailing white space removed, then
"AT" added as a prefix, and "\r" added as a suffix.

=item * All input characters are translated to upper case (even though most
if not all XBees are not case sensitive).

=item * Output lines have "\r" characters replaced with "\n" characters.

=back

Note that if this program exits abnormally (i.e. other than by getting EOF on
its stdin due to Cntrl-D being pressed), the XBee module will remain in command
mode for up to 10 seconds after the last command is issued (unless an explicit
exit-command-mode command ("CN") is issued).

=item B<-r>, B<--raw-mode>

Raw mode.  In this mode, bytes from the standard input may be line-buffered (if
stdin is connection to a terminal) but are otherwise sent unmodified to the
XBee, and data sent to us from the XBee is passed unmodified to our standard
output.

There are some subtle caveats related to RF packetization latency in raw mode,
see the BUGS section.
FIXME: how does this interact with line buffereng??!?!

=back

=head1 AUTHOR

Britton Kerin (britton.kerin@gmail.com)

=cut

# }}}1

# Process Command Line Options/Arguments {{{1

my $help;   # True iff we should just print usage information and exit
my $df;     # Device File
my $cm;     # Command Mode
my $rm;     # Raw Mode

GetOptions(
    "help|?"          => \$help,
    "device-file|d=s" => \$df,
    "command-mode|c"  => \$cm,
    "raw-mode|r"      => \$rm )
    or die "usb_xbee: GetOptions failed, try usb_xbee --help\n";

if ( $help ) {
    pod2usage(-verbose => 1, -exitval => 0);
}

$df or die "--device-file option must be given";

($cm xor $rm)
    or die "exactly one of --command-mode or --raw-mode options must be given";

# }}}1

# We probably don't really need O_SYNC here, but it shouldn't hurt.
sysopen(UD, "$df", O_RDWR | O_SYNC)   # USB Device
    or die "couldn't sysopen device file '$df': $!";

sub configure_tty # {{{1
{
    # Use the stty program to configure the serial device given as an
    # argument st we can send it raw data and it will get through to the
    # XBee unmolested.
    #
    # Its important to undertand that when the stdin and/or stdout of this
    # program are connected to a terminal, the existing settings for that
    # terminal still apply.  We're configuring the settings for the serial
    # connection to the XBee, NOT the ones for the terminal you type into.
    # Thus backspace and such still work.  All your input is resolved into
    # a single line then sent off to the XBee serial port.

    @_ == 1 or die "wrong number of arguments";
    my $df = shift;

    # I *think* this consolidated raw setting is what we want.  Serial port
    # configuration counts as a black art these days IMO.
    not system ("stty -F $df 9600 raw") or die "stty failed";
} # }}}1

sub get_response # {{{1
{
    # Get a response to an AT command (which we assume was previously sent),
    # or die if we get nothing for too long or too much garbage.  The trailing
    # '\r' character which signals the end of the response is returned with
    # the rest of the response.

    my $rt = '';   # Response Text 

    # Maximum Response Length.  If we don't see the "\r" within this many
    # characters, something is wrong.
    my $mrl = 20;

    # Timeout Time.  If we don't see the "\r" within this many seconds,
    # something is wrong.
    my $tt  = 5; 

    # Set an alarm so we'll die instead of hanging forever if we don't get
    # a response.
    $SIG{ALRM}
        = sub
          {
              die "invalid command response: no \"\\r\" within $tt ".
                  "seconds.  Perhaps we exited command mode somehow?";
          };
    alarm($tt);

    for ( my $ii = 0 ; $ii < $mrl ; $ii++ ) {

        my $rr = sysread(UD, $rt, 1, $ii);   # Read Return value
        defined($rr)
            or die "sysread failed on $df: $!.  Perhaps we exited command ".
                   "mode somehow?";
        $rr == 1
            or die "failed to read exactly one character from $df.  Perhaps ".
                   "we exited command mode somehow?";

        if ( substr($rt, $ii, 1) eq "\r" ) {

            # Cancel the alarm
            alarm(0);
            $SIG{ALRM} = 'DEFAULT';

            return $rt;
        }
    }

    # Cancel the alarm
    alarm(0);
    $SIG{ALRM} = 'DEFAULT';

    die "didn't get command response with trailing '\r' within $mrl bytes.  ".
        "Perhaps we exited command mode somehow?";
} # }}}1

sub enter_command_mode # {{{1
{
    # Perform the wait-one-second, send-+++, wait-1-second sequence required
    # to go into command mode, and wait for the result indicating it worked
    # (dying if we don't get it).

    sleep 1;
    my $swr = syswrite(UD, '+++');   # SysWrite Return
    defined($swr)
        or die "syswrite to $df failed: $!";
    $swr == length('+++')
        or die "syswrite didn't write the expected number of bytes to $df";
    sleep 1;

    get_response() eq "OK\r" or die "failed to enter command mode";
} # }}}1

sub leave_command_mode # {{{1
{
    # Leave command mode by issuing the AT command that leaves command mode.

    my $ecmcs = "ATCN\r";   # Exit Command Mode Command String

    my $swr = syswrite(UD, $ecmcs);   # SysWrite Return
    defined($swr)
        or die "syswrite to $df failed: $!";
    $swr == length($ecmcs)
        or die "syswrite didn't write the expected number of bytes to $df";

    get_response() eq "OK\r" or die "failed to leave command mode";
} # }}}1

sub timed_wait_for_stdin # {{{1
{
    # Wait up to the given number of seconds for STDIN to have something we
    # can read.  Return true iff it does.

    @_ == 1 or die "wrong number of arguments";
    my $to = shift;   # Timout, in seconds

    my $rin = '';
    my $rout = '';
    my $sifn = fileno(STDIN);
    vec($rin, $sifn, 1) = 1;
    my $rfc = select($rout = $rin, undef, undef, 2);   # Ready File Count
    $rfc != -1 or die "select failed: $!";
    $rfc == 0 or $rfc == 1
        or die "select indicated an unexpected number of ready files";
    if ( $rfc == 1 ) {
        vec($rout, $sifn, 1) == 1
            or die "select doesn't indicate the expected ready file set";
        return 1;
    }
    else {
        return 0;
    }
} # }}}1

configure_tty($df);

if ( $cm ) {   # Command Mode {{{1

    enter_command_mode();

    my $ki = 4;   # Keepalive Interval (seconds)

    for ( ; ; ) {

        my $gsi = timed_wait_for_stdin($ki);   # Got Standard Input?
        my $cts;   # Command To Send

        if ( $gsi ) {
            # Get the line of input
            $cts = STDIN->getline();
            not STDIN->error() or die "error reading line from STDIN";
            # Now undef means we must have got EOF (possibley from Cntrl-D),
            # so we're done
            defined($cts) or (leave_command_mode() and exit(0));
        }
        else {
            # Note that we'll add the AT and "\r" as for normal commands
            $cts = '';
        }

        # Transform input line as promised
        $cts =~ s/\s*(.*)\s*/$1/;    # Strip leading/trailing white space
        $cts =~ tr/a-z/A-Z/;         # Translate to upper case
        $cts = "AT".$cts."\r";       # Add leading "AT" and trailing "\r"

        # Send stuff to the XBee
        my $swr = syswrite(UD, $cts);
        defined($swr) or die "syswrite failed: $!";
        $swr == length($cts)
            or die "syswrite didn't write the expected number of bytes";

        my $rl = get_response();   # Response Line (from XBee)

        if ( $gsi ) {
            # Transform output line as promised
            $rl =~ s/\r$/\n/
                or die "command response didn't end with a carriage return";

            # Display the output
            print $rl or die "print() (to stdout) failed";
        }
        else {
            $rl eq "OK\r"
                or die "didn't get OK response to empty keep-alive commmand";
        }
    }
} # }}}1

elsif ( $rm ) {   # Raw Mode {{{1

    # In raw mode we can't depend no synchronous responses from the XBee:
    # data could come in at any time, and when it does we want to get it to
    # our stdout ASAP.  At the same time, we want to allow the user to supply
    # data on stdin.  So we select() on both of these potential inputs and
    # move data appropriately as it comes in.

    my ($rin, $rout, $ein, $eout) = ('', '', '', '');
    my $sifn = fileno(STDIN);
    my $udfn = fileno(UD);
    vec($rin, $sifn, 1) = 1;
    vec($rin, $udfn, 1) = 1;

    for ( ; ; ) {

        # Find any inputs that have data (or exceptions) ready for us
        my ($rfc, $tl) = select($rout = $rin, undef, $eout = $ein, undef);
        $rfc != -1 or die "select failed: $!";
        ($rfc >= 0 and $rfc <= 2)
            or die "select indicated an unexpected number of ready files";

        # Check for and report any input exceptions
        if ( vec($eout, $udfn, 1) ) {
            die "select() reported an exception related to file '$df'";
        }
        if ( vec($eout, $sifn, 1) ) {
            die "select() reported an exception related to stdin";
        }

        # For each ready input...
        for ( my $ii = 0 ; $ii < $rfc ; $ii++ ) {

            # If it's data from the XBee module, send it to our stdout
            if ( vec($rout, $udfn, 1) ) {
                my $btrao = 16;   # Bytes To Read At Once (maximum)
                my $rd;           # Read Data
                my $rr = sysread(UD, $rd, $btrao);   # Read Return value
                defined($rr) or die "sysread failed on $df: $!";
                $rr >= 1 or
                    die "sysread() read 0 bytes despite select() saying it ".
                        "had data ready to read";
                print $rd or die "print() (to stdout) failed";
                STDOUT->flush();   # Flush output (avoid line buffering)
            }

            # If it's data from stdin, send it to the XBee module
            if ( vec($rout, $sifn, 1) ) {
                # Note: using getline() means that we may end up sending
                # binary data in funny-sized chunks (because we probably
                # send both on newline and when the stdin buffer gets full).
                # But who cares?  FIXME: packetization cares...  And when
                # stdin is connected to a terminal it's convenient.
                my $dts = STDIN->getline();   # Data To Send
                not STDIN->error() or die "error reading line from STDIN";
                # Now undef means we must have got EOF (possibly from
                # Cntrl-D), so we're done
                defined($dts) or exit(0);

                my $swr = syswrite(UD, $dts);   # SysWrite Return
                defined($swr) or die "syswrite to $df failed: $!";
                $swr == length($dts)
                    or die "syswrite didn't write the expected number of ".
                           "bytes to $df";
            }
        }
    }

} # }}}1

else {
    die "shouldn't be here";
}

exit 0;
